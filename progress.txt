# Progress Notes - In DO Time

## Iteration 1 - Scaffold Next.js project with TailwindCSS and App Router
- What was implemented:
  - Scaffolded Next.js 16.1.6 with App Router and TypeScript
  - TailwindCSS 4.x configured with PostCSS
  - ESLint configured for Next.js
  - Source files in `src/` directory with `@/*` import alias
  - Moved DO Code Lab logo to `public/DO_CODE_LAB_LOGO_NO_TEXT.png`
- Files changed:
  - Created standard Next.js project structure
  - package.json (name: "in-do-time")
  - src/app/layout.tsx, page.tsx, globals.css
  - tsconfig.json, next.config.ts, tailwind.config.ts
  - postcss.config.mjs, eslint.config.mjs
- Learnings for future iterations:
  - Next.js 16 uses TailwindCSS v4 with new PostCSS plugin (@tailwindcss/postcss)
  - React 19 is bundled with Next.js 16
  - create-next-app doesn't allow spaces or caps in project names - must use subdirectory approach
  - Logo placed at public/DO_CODE_LAB_LOGO_NO_TEXT.png as specified in PRD
---

## Iteration 2 - Set up Supabase client and environment variables
- What was implemented:
  - Created .env.example with Supabase URL and anon key template
  - Created .env.local for local development (gitignored)
  - Created src/lib/supabase.ts with typed Supabase client
  - Created src/types/database.ts with full TypeScript types matching PRD schema
  - Updated .gitignore to track .env.example but ignore .env.local
- Files changed:
  - .env.example (new)
  - .env.local (new, gitignored)
  - src/lib/supabase.ts (new)
  - src/types/database.ts (new)
  - .gitignore (updated)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - @supabase/supabase-js was already installed in package.json
  - Database types include Row, Insert, Update variants for each table
  - Convenience types (Client, Project, TimeEntry) exported for easier use
  - Next.js build confirms .env.local is loaded (shows "Environments: .env.local")
---

## Iteration 3 - Run database schema migration (create all 3 tables + indexes)
- What was implemented:
  - Created supabase/migrations/001_initial_schema.sql with full schema
  - All 3 tables: clients, projects, time_entries
  - All 3 indexes: idx_time_entries_project, idx_time_entries_start, idx_projects_client
  - Added updated_at triggers for automatic timestamp updates
  - Enabled RLS with permissive policies (single-user MVP, no auth)
  - Created supabase/README.md with setup instructions
- Files changed:
  - supabase/migrations/001_initial_schema.sql (new)
  - supabase/README.md (new)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Migration file uses IF NOT EXISTS for idempotent runs
  - RLS must be enabled with permissive policies for anon access
  - Migration is meant to be run in Supabase SQL Editor (not automated CLI)
  - Build and lint pass - project remains in healthy state
---

## Iteration 4 - Place DO Code Lab logo in public/ and generate favicon
- What was implemented:
  - Logo already existed at public/DO_CODE_LAB_LOGO_NO_TEXT.png (from iteration 1)
  - Generated 32x32 icon.png from logo using macOS sips
  - Generated 180x180 apple-icon.png for Apple touch devices
  - Removed default favicon.ico
  - Updated layout.tsx metadata title to "In DO Time"
  - Updated layout.tsx metadata description to "Multi-client time tracking for DO Code Lab"
- Files changed:
  - src/app/icon.png (new - generated from logo)
  - src/app/apple-icon.png (new - generated from logo)
  - src/app/favicon.ico (deleted)
  - src/app/layout.tsx (updated metadata)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Next.js App Router auto-detects icon.png and apple-icon.png in app/ directory
  - macOS sips is available for image conversion when ImageMagick isn't installed
  - Build output shows /icon.png and /apple-icon.png as static routes when properly placed
  - Favicon should be in app/ dir not public/ for App Router convention
---

## Iteration 5 - Create app layout with branded header (logo + "In DO Time" + nav)
- What was implemented:
  - Updated globals.css with DO Code Lab brand colors using TailwindCSS v4 @theme inline
  - Configured all brand colors: primary, primary-dark, primary-light, surface, accent, text, border, etc.
  - Added design tokens for border radius (button: 8px, card: 12px) and card shadows
  - Created Header component with DO Code Lab logo (40px), "In DO Time" title, and nav links
  - Navigation includes: Dashboard, Time Log, Reports, Clients with active state styling
  - Updated layout.tsx to use Playfair Display (headings) and Inter (body) fonts from Google Fonts
  - Layout includes Header component and main content area with max-w-7xl container
  - Updated page.tsx with simple placeholder using brand styling
- Files changed:
  - src/app/globals.css (updated with brand colors and design tokens)
  - src/components/Header.tsx (new)
  - src/app/layout.tsx (updated with fonts and Header)
  - src/app/page.tsx (updated with placeholder content)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - TailwindCSS v4 uses @theme inline block for custom CSS variables
  - Font variables are set via next/font/google and consumed in CSS via var(--font-name)
  - Header uses 'use client' for usePathname hook to highlight active nav item
  - Brand colors accessible as Tailwind classes like bg-primary, text-primary-dark, etc.
  - Components go in src/components/ directory with @/components/* imports
---

## Iteration 6 - Build Client CRUD (add, edit, archive clients with name, hourly rate, color)
- What was implemented:
  - Created /clients page with full CRUD functionality
  - List view shows all active clients in card-based grid layout (3 columns desktop, responsive)
  - Each card displays: name, hourly rate, color indicator, edit/archive buttons
  - Add client modal with form: name (required), hourly rate, color picker (8 preset colors)
  - Edit client functionality reuses same modal
  - Archive/restore functionality with confirmation dialog
  - Toggle to show/hide archived clients
  - Error handling with user-friendly messages
  - Loading states during data fetch
- Files changed:
  - src/app/clients/page.tsx (new - full Client CRUD page)
  - src/types/database.ts (updated - added Relationships property for Supabase SDK v2 compatibility)
  - src/lib/supabase.ts (updated - lazy initialization pattern to avoid build-time errors)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Supabase SDK v2 requires Relationships property in each table definition for TypeScript
  - Supabase client must use lazy initialization to avoid build errors when env vars missing
  - ESLint rule react-hooks/set-state-in-effect is VERY strict - cannot call setState synchronously in useEffect body
  - Workaround: call setState only in .then() callbacks or event handlers, not at effect start
  - Use refreshTrigger pattern to trigger re-fetches: increment counter + add to useEffect deps
  - Client colors stored as hex strings in database, rendered with inline styles
---

## Iteration 7 - Build Project CRUD (add, edit, archive projects under clients with optional rate override)
- What was implemented:
  - Created /projects page with full CRUD functionality
  - List view shows all projects in card-based grid layout with client color border
  - Each card displays: project name, client name, effective hourly rate, edit/archive buttons
  - Add project modal with form: client selection (dropdown), name, optional hourly rate override
  - Edit project functionality reuses same modal
  - Archive/restore functionality with confirmation dialog
  - Toggle to show/hide archived projects
  - Shows warning when no clients exist (can't create projects without a client)
  - Displays "(override)" indicator when project uses custom rate vs client rate
  - Added Projects link to Header navigation
- Files changed:
  - src/app/projects/page.tsx (new - full Project CRUD page)
  - src/components/Header.tsx (updated - added Projects nav link)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Supabase select with relations: `.select('*, clients(id, name, color, hourly_rate)')`
  - Relations come back as nested object (project.clients.name)
  - Use Promise.all to load multiple resources (projects + clients) in parallel
  - getEffectiveRate helper function determines if override or client rate applies
  - Disable "Add Project" button when no clients exist (required foreign key)
---

## Iteration 8 - Create timer engine: start timer → creates time_entry with is_running=true
- What was implemented:
  - Created src/lib/timer.ts with core timer engine functions
  - startTimer(projectId, notes?) → creates time_entry with is_running=true, start_time=now
  - getRunningTimers() → fetches all time entries where is_running=true
  - getRunningTimerForProject(projectId) → get running timer for specific project
  - hasRunningTimer(projectId) → boolean check if project has running timer
  - Helper utilities: calculateElapsedSeconds, formatDuration, calculateRunningCost, formatCurrency
- Files changed:
  - src/lib/timer.ts (new - timer engine core)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Timer engine is a pure TypeScript lib file (not a React component)
  - Uses getSupabase() pattern for lazy client initialization
  - TimeEntryInsert type matches database schema exactly
  - PGRST116 error code means "no rows found" - expected when checking for running timers
  - formatDuration returns HH:MM:SS format, padded with zeros
  - Timer state persists in Supabase - can survive browser refresh
---

## Iteration 9 - Stop timer → sets end_time, calculates duration_seconds, sets is_running=false
- What was implemented:
  - Added stopTimer(timeEntryId) function to timer engine
  - Fetches current entry to verify it exists and is_running=true
  - Calculates duration_seconds using existing calculateElapsedSeconds helper
  - Updates entry with end_time (ISO string), duration_seconds, is_running=false
  - Added convenience function stopTimerForProject(projectId) that finds and stops the running timer
  - Both functions return TimerResult with success/error states
- Files changed:
  - src/lib/timer.ts (added stopTimer and stopTimerForProject functions)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Stop timer must first fetch entry to get start_time for duration calculation
  - Validation checks: entry must exist AND is_running must be true
  - Two stop variants: by timeEntryId (direct) and by projectId (convenience)
  - Pattern: fetch first, validate, then update - prevents race conditions
---

## Iteration 10 - Pause/resume functionality (stop current entry, start new one on resume)
- What was implemented:
  - Added pauseTimer(projectId) → delegates to stopTimerForProject (stops current entry)
  - Added resumeTimer(projectId, copyNotes?) → starts new entry, optionally copies notes from last entry
  - Added getLastEntryForProject(projectId) → gets most recent entry for a project
  - Added getPausedTimerForProject(projectId) → checks if project has a "paused" state (stopped within 24h)
  - Added getTimerStateForProject(projectId) → returns 'running' | 'paused' | 'stopped' with entry
  - Added TimerState type export
- Files changed:
  - src/lib/timer.ts (added 5 new functions + 1 type)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Pause is semantically distinct from stop, but uses same underlying mechanism
  - "Paused" state determined by having a stopped entry within 24 hours
  - copyNotes=true by default on resume to continue work context
  - TimerState type enables UI to show different button states per project
  - Pattern: pause/resume creates separate time entries (not a single paused entry)
---

## Iteration 11 - Support multiple simultaneous running timers (one per project)
- What was implemented:
  - Added validation to startTimer() to prevent multiple running timers per project
  - startTimer now checks getRunningTimerForProject() before creating new entry
  - Added RunningTimerWithProject interface for dashboard display
  - Added getAllRunningTimersWithProjects() - fetches all running timers with nested project + client data
  - Added getRunningTimerCount() - quick count for dashboard indicators
  - Uses Supabase nested select: time_entries → projects → clients
  - Returns effectiveRate (project override or client rate) for each running timer
- Files changed:
  - src/lib/timer.ts (added validation to startTimer, added 3 new exports)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Multiple simultaneous timers already worked via getRunningTimers() returning all
  - Key constraint "one per project" enforced by validation in startTimer and resumeTimer
  - Supabase nested joins: `projects!inner(..., clients!inner(...))` for multi-level relations
  - eslint @typescript-eslint/no-explicit-any needed for complex Supabase return types
  - RunningTimerWithProject provides dashboard-ready structure with effectiveRate pre-calculated
---

## Iteration 12 - Timer state persists in Supabase (survives browser close/refresh)
- What was implemented:
  - Verified existing timer engine already persists all state to Supabase
  - startTimer() creates time_entry rows with is_running=true in Supabase
  - stopTimer() updates rows with end_time, duration_seconds, is_running=false
  - getRunningTimers() and getAllRunningTimersWithProjects() fetch from Supabase
  - No code changes needed - persistence was inherent to the Supabase-based design
- Files changed:
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Timer persistence was already built into the architecture from iteration 8
  - All timer functions use getSupabase() and perform CRUD on time_entries table
  - Browser close/refresh survives because state is in database, not memory
  - This was essentially a verification task - the design was correct from the start
---

## Iteration 13 - On app load, detect any is_running=true entries and resume display
- What was implemented:
  - Created src/hooks/useRunningTimers.ts - React hook that detects running timers on mount
  - Hook calls getAllRunningTimersWithProjects() on mount and ticks elapsed seconds every 1s
  - Returns timers with live elapsedSeconds, loading/error states, refresh callback
  - Created src/components/ActiveTimers.tsx - displays running timers with live ticking UI
  - Each timer card shows: client name, project name, elapsed time (HH:MM:SS), running cost
  - Green pulsing indicator for running state, Pause and Stop buttons
  - Cards styled with client color border, amber accent for timer display
  - Updated src/app/page.tsx to include ActiveTimers component at top of dashboard
  - Component renders nothing when no timers are running (clean empty state)
- Files changed:
  - src/hooks/useRunningTimers.ts (new)
  - src/components/ActiveTimers.tsx (new)
  - src/app/page.tsx (updated)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - useRunningTimers hook uses useRef for interval to avoid stale closure issues
  - Interval only runs when timers.length > 0, cleaned up when timers empty
  - calculateElapsedSeconds recomputes from start_time each tick (avoids drift)
  - ActiveTimers returns null when no running timers (doesn't render empty container)
  - Pattern: 'use client' directive needed in hook file for useState/useEffect
  - Hooks directory created at src/hooks/ for custom React hooks
  - Next.js allows mixing server (page.tsx) and client (ActiveTimers) components seamlessly
---

## Iteration 14 - Card-based dashboard showing all active projects with timer controls
- What was implemented:
  - Created src/components/Dashboard.tsx - full card-based dashboard component
  - Fetches all active projects with client info from Supabase
  - Detects running timers and shows live ticking elapsed time + running cost
  - Detects paused projects (stopped within 24h) and shows "Resume" button
  - Start/Pause/Stop/Resume buttons per project card with loading states
  - Green pulsing indicator for running timers, amber dot for paused
  - Cards styled with client color border, responsive 3-col grid
  - Running timer count summary bar at top
  - Empty state with links to Clients/Projects pages
  - Replaced old placeholder page.tsx with Dashboard component
  - Removed dependency on standalone ActiveTimers component (Dashboard is now unified)
- Files changed:
  - src/components/Dashboard.tsx (new - full dashboard component)
  - src/app/page.tsx (updated - now renders Dashboard instead of placeholder + ActiveTimers)
- Learnings for future iterations:
  - Dashboard replaces ActiveTimers on home page - shows ALL projects, not just running ones
  - ActiveTimers.tsx still exists and could be reused elsewhere if needed
  - getPausedTimerForProject makes individual queries per project - may be slow with many projects
  - Timer map (Map<string, TimerDisplayInfo>) is efficient for lookup by projectId
  - setInterval with Map state update works for multi-timer ticking
  - Supabase nested select with !inner ensures only projects with valid clients are returned
  - eslint @typescript-eslint/no-explicit-any needed for Supabase join return types
---

## Iteration 15 - Quick-start: click a project card to begin timing + mark already-done Phase 3 tasks
- What was implemented:
  - Made project cards clickable for quick-start: clicking an idle card starts timer, clicking paused card resumes
  - Added stopPropagation on controls div to prevent card click from firing when using buttons
  - Added cursor-pointer class for clickable cards (idle + paused states)
  - Running cards are not clickable (they already have dedicated Pause/Stop buttons)
  - Marked 4 Phase 3 tasks as complete that were already implemented in Iteration 14:
    - Each card: client name, project name, live elapsed time (ticking), running cost
    - Start/Stop/Pause buttons per card
    - Green pulsing indicator for running timers, amber accent for active states
    - Responsive layout: 3 columns desktop, 1 column mobile
- Files changed:
  - src/components/Dashboard.tsx (added card click handler + stopPropagation on controls)
  - PRD.md (marked 5 Phase 3 tasks complete)
- Learnings for future iterations:
  - Many Phase 3 tasks were already implemented during Iteration 14 (card-based dashboard)
  - Always check existing implementation before starting new work
  - stopPropagation on button container prevents card-level click from firing on button clicks
  - canQuickStart flag prevents accidental double-starts when a timer is already running
---

## Iteration 16 - "Recent Activity" section below cards showing today's logged entries
- What was implemented:
  - Added RecentEntry interface for typed recent activity data
  - In loadData, fetches today's completed time entries (is_running=false, start_time >= midnight today)
  - Joins time_entries → projects → clients for full context
  - "Recent Activity" section renders below project cards grid
  - Each entry shows: client color dot, project name, notes, client name, time range, duration (HH:MM:SS), cost
  - Entry count summary: "Today: N entries"
  - Styled with rounded card container, dividers between entries, truncation for long text
  - Section only renders when there are entries (clean empty state)
  - Recent entries refresh after every timer start/stop/pause/resume action
- Files changed:
  - src/components/Dashboard.tsx (added RecentEntry interface, fetch logic, JSX section)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Supabase .gte() filter works with ISO date strings for date range queries
  - todayStart.setHours(0,0,0,0) gives local midnight - consistent with user expectations
  - Nested Supabase select for time_entries → projects → clients: `projects!inner(name, ..., clients!inner(...))`
  - toLocaleTimeString with {hour: 'numeric', minute: '2-digit'} gives clean time display
  - Recent Activity auto-refreshes via loadData() being called after every timer action
---

## Iteration 17 - Today's summary: total hours + total earnings
- What was implemented:
  - Added "Today's Summary" card at top of dashboard showing total hours and total earnings
  - Aggregates completed entries (recentEntries) + currently running timers for real-time totals
  - Running timer seconds tick live via the existing interval, keeping summary always current
  - Styled with primary-light background, brand colors, monospace numbers
  - Summary only appears when there's activity (totalSeconds > 0)
- Files changed:
  - src/components/Dashboard.tsx (added summary calculation logic + JSX section)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - recentEntries already has all data needed for completed time totals (duration_seconds + effectiveRate)
  - Running timer totals computed by iterating runningTimers Map and looking up project rates
  - calculateRunningCost(seconds, rate) reused for both completed and running calculations
  - Summary updates live because runningTimers state updates every second via setInterval
  - Used &apos; for apostrophe in JSX to satisfy ESLint react/no-unescaped-entities
---

## Iteration 18 - Time log page: chronological list of all time entries
- What was implemented:
  - Created /time-log page with full chronological listing of all time entries
  - Entries fetched from Supabase with nested project + client data
  - Grouped by date with date headers showing daily totals (hours + earnings)
  - Each entry displays: client color dot, project name, client name, start/end time, duration, cost
  - Running timers shown with green pulsing "Running" badge and "—" for duration/cost
  - Manual entries marked with "Manual" badge
  - Notes displayed inline when present
  - Empty state with link back to Dashboard
  - Loading and error states with retry button
  - Entry count shown in page subtitle
- Files changed:
  - src/app/time-log/page.tsx (new - full time log page)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Reused same Supabase nested select pattern: time_entries → projects!inner → clients!inner
  - Grouped entries by date using reduce with toLocaleDateString as key
  - Follows same UI patterns as Dashboard: rounded-card, divide-y, shadow-card
  - Running entries show "Running" instead of end time/duration/cost
  - Daily totals calculated per group for quick at-a-glance summary
  - Header already had /time-log nav link from iteration 7
---

## Iteration 19 - Filter by client, project, and date range
- What was implemented:
  - Added filter bar to Time Log page with Client dropdown, Project dropdown, From date, and To date
  - Client and Project dropdowns populated from Supabase on mount
  - Project dropdown filters by selected client (shows only relevant projects)
  - Selecting a client clears project selection to avoid mismatches
  - Date range uses native HTML date inputs with gte/lte Supabase filters
  - Filters applied at query level (Supabase) for efficiency, not client-side
  - "Clear" button appears only when filters are active
  - Entry count shows "(filtered)" when filters are active
  - Empty state shows "No matching entries" with clear filters link when filtered
  - Fixed pre-existing ESLint issue: replaced `<a>` with `<Link>` from next/link
  - Added project_id and client_id to TimeLogEntry interface for filter support
- Files changed:
  - src/app/time-log/page.tsx (updated - added filter UI and query logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Supabase .gte() and .lte() work directly on timestamptz columns with ISO strings
  - For client filtering through a relation: `.eq('projects.client_id', clientId)` with !inner join
  - Project filter uses direct `.eq('project_id', id)` since it's on the time_entries table
  - When selecting client, clear project selection to avoid stale filter state
  - loadEntries depends on filter state via useCallback deps array - auto-refetches on filter change
  - End date needs setHours(23,59,59,999) to include entries on that day
  - `next/link` Link component required instead of `<a>` for internal navigation (ESLint rule)
---

## Iteration 20 - Each entry: project, client, start/end time, duration, calculated cost
- What was implemented:
  - Verified this was already fully implemented in Iteration 18 (Time Log page)
  - Each entry shows: project name, client name, start/end time, duration (HH:MM:SS), calculated cost
  - Running entries show "Running" badge and "—" for duration/cost
  - No code changes needed - just marked the PRD task complete
- Files changed:
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Some PRD tasks overlap with earlier implementations - always check existing code first
  - The time-log/page.tsx already had all required fields from the initial implementation
  - Build and typecheck both pass cleanly
---

## Iteration 21 - Edit entries (adjust start/end times for corrections)
- What was implemented:
  - Added updateTimeEntry() function to src/lib/timer.ts for editing time entries
  - Auto-recalculates duration_seconds when start_time or end_time changes
  - Added edit modal to Time Log page with datetime-local inputs for start/end times
  - Edit modal also allows editing notes
  - Pencil icon edit button on each completed entry row (not shown for running entries)
  - Validation: end time must be after start time
  - Loading state on save button, error display in modal
  - Entry list refreshes after successful edit
- Files changed:
  - src/lib/timer.ts (added updateTimeEntry function, imported TimeEntryUpdate type)
  - src/app/time-log/page.tsx (added edit state, modal, edit button, save handler)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - datetime-local input needs YYYY-MM-DDTHH:MM format, not ISO string
  - toDatetimeLocal helper converts ISO to local datetime format using local timezone
  - Edit button hidden for running entries (they should be stopped first)
  - updateTimeEntry smartly recalculates duration when either time changes
  - Modal uses fixed inset-0 z-50 with black/50 backdrop for overlay pattern
---

## Iteration 22 - Delete entries with confirmation dialog
- What was implemented:
  - Added deleteTimeEntry() function to src/lib/timer.ts
  - Prevents deleting running timers (must stop first)
  - Added trash icon delete button next to edit button on each completed entry row
  - Confirmation dialog shows entry details (project, client, date, duration, cost) before deleting
  - Loading state on delete button, list refreshes after successful delete
- Files changed:
  - src/lib/timer.ts (added deleteTimeEntry function)
  - src/app/time-log/page.tsx (added delete state, handler, button, confirmation dialog)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Delete button and edit button now wrapped in a flex container with gap-1 for consistent spacing
  - Confirmation dialog uses red color scheme (bg-red-600) to indicate destructive action
  - Delete blocked for running entries same as edit - consistent UX pattern
  - Supabase .delete().eq('id', id) returns no data by default, just error on failure
  - Reused same modal overlay pattern: fixed inset-0 z-50 bg-black/50
---

## Iteration 23 - Manual time entry option (add time after the fact)
- What was implemented:
  - Added createManualEntry() function to src/lib/timer.ts
  - Creates time_entry with is_manual=true, is_running=false, pre-calculated duration
  - Validates end time > start time before insert
  - Added "+ Manual Entry" button in Time Log page header
  - Added manual entry modal with project dropdown, start/end datetime pickers, notes field
  - Form validation: project required, both times required, end must be after start
  - Entry list refreshes after successful save
  - Modal reuses existing project list from filter dropdowns (loaded on mount)
- Files changed:
  - src/lib/timer.ts (added createManualEntry function)
  - src/app/time-log/page.tsx (added manual entry button, state, modal, handler)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - createManualEntry is simpler than startTimer - no is_running checks needed
  - Reused projects list from filter dropdown state - no additional Supabase query needed
  - Manual entries get is_manual=true flag, already displayed with "Manual" badge in time log
  - Same modal overlay pattern: fixed inset-0 z-50 bg-black/50
  - datetime-local inputs work well for manual entry (user picks exact date+time)
---

## Iteration 24 - Reports page: summary view grouped by client → project
- What was implemented:
  - Created /reports page with summary view grouped by client → project
  - Fetches all completed time entries (is_running=false) with nested project + client data
  - Groups entries into ClientSummary → ProjectSummary hierarchy with totals
  - Grand totals bar showing total time, total earned, entry count, client count
  - Each client card: color dot, name, entry/project count, total time, total earned
  - Collapsible client sections with chevron toggle (expanded by default)
  - Project breakdown within each client: name, entry count, time, cost
  - Sorted by total cost descending (highest-earning clients/projects first)
  - Filter bar: Client dropdown, From date, To date with Clear button
  - Filters applied at Supabase query level for efficiency
  - Loading, error, and empty states matching existing patterns
- Files changed:
  - src/app/reports/page.tsx (new - full reports page)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Reused same Supabase nested select pattern: time_entries → projects!inner → clients!inner
  - Map-based grouping (Map<clientId, ClientSummary>) is clean for multi-level aggregation
  - Collapsible sections use simple Record<string, boolean> state for toggle tracking
  - Reports only show completed entries (is_running=false) - running timers excluded
  - Grand totals computed from clientSummaries array with reduce
  - Header already had /reports nav link from iteration 5
---

## Iteration 25 - CSV export filtered by client + date range
- What was implemented:
  - Created src/lib/csv.ts with CSV generation, download, and filename utilities
  - generateCSV() creates CSV with columns: Client, Project, Date, Start/End Time, Duration, Hours (Decimal), Hourly Rate, Cost, Notes, Type
  - escapeCSV() handles commas, quotes, and newlines in field values
  - downloadCSV() triggers browser file download via Blob URL
  - generateCSVFilename() creates descriptive filename based on active filters
  - Added "Export CSV" button to Reports page header (green primary button with download icon)
  - Button only appears when there are entries to export
  - CSV export uses the same filtered data as the on-screen report (same client + date range filters)
  - Added end_time, notes, is_manual fields to ReportEntry interface and Supabase query
  - Stored reportEntries in state for CSV generation
- Files changed:
  - src/lib/csv.ts (new - CSV generation and download utilities)
  - src/app/reports/page.tsx (updated - added Export CSV button, expanded query fields, stored entries)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - CSV export uses native JS Blob + URL.createObjectURL for browser download (no library needed)
  - Filename includes filter context (client name, date range) for easy identification
  - ReportEntry interface needed expansion (end_time, notes, is_manual) for complete CSV rows
  - Export button conditionally rendered based on reportEntries.length > 0
  - Hours (Decimal) column useful for invoicing (e.g., 1.50 = 1h 30m)
---

## Iteration 26 - Include DO Code Lab logo in report header
- What was implemented:
  - Added DO Code Lab logo (48x48px) to the Reports page header, next to the "Reports" title
  - Used Next.js Image component for optimized image loading
  - Logo and title wrapped in flex container with gap-3 for clean alignment
  - Logo uses flex-shrink-0 to prevent shrinking on small screens
- Files changed:
  - src/app/reports/page.tsx (added Image import, added logo to header)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Logo is at public/DO_CODE_LAB_LOGO_NO_TEXT.png (placed in iteration 1)
  - Next.js Image component requires explicit width/height props
  - PRD specifies larger logo for report exports vs nav (32-40px nav, larger for reports)
  - 48px works well as a report header size - prominent but not overwhelming
---

## Iteration 27 - Responsive design pass (mobile + desktop)
- What was implemented:
  - Time Log page: moved edit/delete buttons to inline text on mobile (hidden icon buttons, show text buttons below entry), notes shown on separate line on mobile
  - Reports page: reduced padding on client headers and project breakdowns for mobile (px-3, pl-8 vs px-5, pl-12), smaller font sizes for monospace values on mobile
  - Reports page: hide "Time"/"Earned" sub-labels on mobile to save space, truncate long client/project names
  - Clients page: added p-4 padding on modal overlay for mobile (prevents edge-to-edge modal)
  - Projects page: same modal overlay padding fix
  - Dashboard: recent activity entries have tighter gap/padding on mobile, notes hidden inline on small screens, smaller duration text on mobile
  - Dashboard: timer control buttons slightly taller (py-2.5) on mobile for better touch targets
  - Header: brand text slightly smaller (text-lg) on mobile, (text-xl) on sm+
  - Layout: reduced vertical padding on mobile (py-6 vs py-8 on sm+)
- Files changed:
  - src/app/time-log/page.tsx (mobile action buttons, notes layout)
  - src/app/reports/page.tsx (tighter spacing, responsive font sizes)
  - src/app/clients/page.tsx (modal padding)
  - src/app/projects/page.tsx (modal padding)
  - src/components/Dashboard.tsx (recent activity, touch targets)
  - src/components/Header.tsx (brand text size)
  - src/app/layout.tsx (mobile padding)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Most of the responsive foundation was already solid (grid-cols responsive, flex-col/row patterns)
  - Main issues were: overly generous padding on mobile, icon buttons too small for touch, notes causing overflow
  - Pattern: hidden sm:flex for desktop-only elements, sm:hidden for mobile-only alternatives
  - Touch targets should be at least py-2.5 (40px total height) on mobile
  - Modals always need p-4 on the backdrop for safe mobile padding
---
